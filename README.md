# Smart Pay
#### Описание API для подключения кассы
----
## Общие сведения
Платёжный сервис KD Pay/Smart Pay обеспечивает проведение платежей на основе технологий СБП “me-2-me pull” и Сервиса привязки счета (“Подписка”). Для этого сервис реализует два основных API: клиентский API и кассовый API. Данный документ описывает кассовый API. 

## Тестовое окружение
Для проведения разработки и отладки сервис использует следующие тестовые окружения: `http://kassa-api.test.r-proc.net`
Для авторизации используется клиентский ssl-сертификат. Чтобы получить сертификат для тестовой среды, напишите запрос на адрес kkt-integration@r-proc.ru

## Описание API
Наиболее полное описание API в формате OpenAPI 3.0 доступно тут http://kassa-api.test.r-proc.net/api/docs/v1/
Цель данного документа описать основные сценарии использования кассового API и уточнить детали его использования, первоисточником следуем считать описание в формате OpenAPI 3.0, при расхождения верным следует считать последнее.

## Описание сценариев
### Авторизация
Перед вызовом всех прочих методов API касса должна авторизоваться с помощью метода `/v1/auth`. В ответ касса получит в куках авторизационную сессию, которую необходимо передавать при вызове остальных методов API.
### Оплата
Для проведения платежа касса должна считать QR-код, предъявленный покупателем. Полученные данные используются кассой как для взаимодействия с процессингом лояльности, так и для проведения платежа. Структура QR-кода описана ниже.
Сценарий оплаты состоит из нескольких активных действий со стороны кассы:
1. При предъявлении QR-кода касса должна как можно быстрее “зафиксировать” его, чтобы исключить предъявление копии того же QR-кода на другой кассе. Так как покупатель может предъявить QR-код в любой момент (до того, как кассир начал пробивать покупки, в середине этого процесса или в конце), то данная операция не оперирует суммой покупки.
2. Для “фиксации” кода используется метод `/v1/purchase/code/commit`. В качестве параметров необходимо передать данные полученные из QR-кода и уникальный идентификатор данной покупки на данной кассе `kassa_purchase_id`. Он должен быть уникален в рамках каждой кассы. В качестве такого идентификатора можно использовать unix timestamp момента создания нового фискального документа. В данном методе происходит расшифровка полученных данных из QR-кода и проверка их валидности, после чего создается объект покупки.
3. В ответ касса получает идентификатор покупки на стороне платёжного сервиса, данный идентификатор используется на следующих шагах.
4. После того, как кассир закончил пробивать все покупки касса должна инициировать оплату с помощью метода “KD Pay”/“Smart Pay”. Для этого используется метод `/v1/purchase/release`, важно отметить, что в этот метод в качестве параметра передается сумма покупки. В этом методе по данным покупки определяется тип оплаты (“me-2-me pull” или платеж по “Подписке”) и запускается процесс оплаты.
5. После того, как касса успешно инициировала оплату, она должна в цикле запрашивать статус платежа с помощью метода `/v1/purchase/status`. После того, как касса получила успешный статус платежа, кассир может отдавать покупки покупателю.
6. Касса должна сообщить платежному сервису, что транзакция успешна завершена со стороны кассы. Используется метод `/v1/purchase/kassa/status`.
7. Для отображения истории покупок в мобильном приложении касса должна сохранить данные фискального чека в платежном сервисе. Используется метод `/v1/purchase/fiscal`. В качестве параметров передаются регистрационный номер кассы и фискальный признак чека. Существует также метод второй версии `/v2/purchase/fiscal` куда передается два основных блока данных - данные полученные из QR-кода и данные самого чека. Данные чека могут быть переданы независимо от того, была ли покупка оплачена с помощью KD Pay/Smart Pay или другим способом оплаты. Рекомендуется использовать метод второй версии, чтобы впоследствии отображать чеки в мобильном приложении торговой сети.

### Структура QR-кода
QR-код, формируется мобильным приложением (МП). Базово QR должен содержать идентификатор в программе лояльности и ОТР для подтверждения платежной транзакции. Так как в прикассовой зоне может не быть стабильного мобильного интернета, то ОТP получаются приложением заранее при каждом запуске. Для уменьшения рисков несанкционированного использования QR-кода OTP передается в зашифрованном виде внутри структуры с метаданными.
QR код представляет JSON структуру следующего вида:

`{
  "encrypted": "string",
  "sign": "string"
}`

* `encrypted` - строка сформированная как результат base64 преобразования зашифрованной строки вида `<otp>.<timestamp>.<user_id>.<loyalty_id>`, где otp - пароль подтверждающий конкретную транзакцию, timestamp - временная метка utc полученная, в момент демонстрации qr в МП, user_id - идентификатор пользователя, который совершает платеж, loyalty_id - не обязательный идентификатор пользователя в программе лояльности, формат определяется мобильным приложением. Для шифрования используется публичный ключ платежного сервиса.

* `sign` - строка сформированная как результат base64 преобразования электронной подписи строки вида `<otp>.<timestamp>.<user_id>.<loyalty_id>`, где otp - пароль подтверждающий конкретную транзакцию, timestamp - временная метка utc полученная, в момент демонстрации qr в МП, user_id - идентификатор пользователя, который совершает платеж, loyalty_id - не обязательный идентификатор пользователя в программе лояльности, формат определяется мобильным приложением. Для подписи используется приватный ключ МП.

### Отмена оплаты
Если в процессе оплаты покупатель или кассир решают прервать процесс ожидания подтверждения оплаты от платежного сервиса, то касса должна явно уведомить об этом платежный сервис, с помощью метода `/v1/purchase/kassa/status` отправив статус cancel. После получения этого статуса со стороны кассы платежный сервис самостоятельно отменит платеж на своей стороне.

### Возврат
Возврат происходит по стандартным правилам магазина (торговой сети). 
Для непосредственного осуществления возврата касса должна выполнить следующие действия:
1. Запросить возврат с помощью метода `/v1/purchase/refund`. Возврат может быть сделан только в рамках какого-то, ранее проведенного платежа. Поэтому в качестве параметра в метод передается идентификатор платежа, по которому необходимо сделать возврат и сумма, на которую будет совершен возврат (может быть совершен частичный возврат, например на часть товаров из платежа). Параметр `kassa_refund_id` представляет собой уникальный идентификатор возврата на стороне кассы, по смыслу совпадает с параметром `kassa_purchase_id` и может быть сформирован таким же образом.
2. В ответ касса получает уникальный идентификатор возврата со стороны платежного сервиса, он используется в последующих запросах.
3. Платежный сервис со своей стороны контролирует, что платеж, по которому запрошен возврат существует, был ранее завершен в статусе “Успешен” и общая сумма возвратов не больше исходной суммы платежа.
4. После того, как возврат запрошен, касса в цикле опрашивает платежный сервис, для получения статуса возврата с помощью метода `/v1/purchase/refund/status`.
5. Подтверждение от кассы о том, что возврат прошел успешно не требуется. Метод `/v1/purchase/refund/kassa/status`  на данный момент не поддержан, в дальнейшем, с помощью этого метода, касса сможет прервать ожидание возврата, отправив статус cancel (см. Отмена оплаты).

### Сертификаты
Есть несколько методов для взаимодействия кассы с сертификатами.
1. POST `/v1/kassa/cert` метод для перевыпуска сертификата для кассы. На вход касса должна передать свой идентификатор, после чего ее сертификат будет перевыпущен.
2. Помощью метода GET `/v1/kassa/cert` можно получить информацию по сертификату, передав идентификатор сертифика, который приходит в ответе метода для перевыпуска сертификата.

### Вспомогательные методы
Платежный сервис также реализует несколько вспомогательных методов.
1. Касса может проверить доступность и работоспособность платежного сервиса с помощью метода `/v1/ping`
2. Список всех возможных ошибок можно получить с помощью метода `/v1/error_answers`
